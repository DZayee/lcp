use crate::errors::AttestationReportError as Error;
#[cfg(feature = "sgx")]
use crate::sgx_reexport_prelude::*;
use anyhow::anyhow;
use chrono::prelude::DateTime;
use crypto::Address;
use pem;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use sgx_types::sgx_quote_t;
use std::string::{String, ToString};
use std::time::SystemTime;
#[cfg(feature = "sgx")]
use std::untrusted::time::SystemTimeEx;
use std::vec::Vec;
use std::{format, ptr};

pub const IAS_REPORT_CA: &[u8] =
    include_bytes!("../../../enclave/Intel_SGX_Attestation_RootCA.pem");

type SignatureAlgorithms = &'static [&'static webpki::SignatureAlgorithm];
static SUPPORTED_SIG_ALGS: SignatureAlgorithms = &[
    &webpki::ECDSA_P256_SHA256,
    &webpki::ECDSA_P256_SHA384,
    &webpki::ECDSA_P384_SHA256,
    &webpki::ECDSA_P384_SHA384,
    &webpki::RSA_PSS_2048_8192_SHA256_LEGACY_KEY,
    &webpki::RSA_PSS_2048_8192_SHA384_LEGACY_KEY,
    &webpki::RSA_PSS_2048_8192_SHA512_LEGACY_KEY,
    &webpki::RSA_PKCS1_2048_8192_SHA256,
    &webpki::RSA_PKCS1_2048_8192_SHA384,
    &webpki::RSA_PKCS1_2048_8192_SHA512,
    &webpki::RSA_PKCS1_3072_8192_SHA384,
];

/// AttestationReport can be endorsed by either the Intel Attestation Service
/// using EPID or Data Center Attestation
/// Service (platform dependent) using ECDSA.
#[derive(Default, Debug, Serialize, Deserialize)]
pub struct EndorsedAttestationReport {
    /// Attestation report generated by the hardware
    pub report: Vec<u8>,
    /// Singature of the report
    pub signature: Vec<u8>,
    /// Certificate matching the signing key of the signature
    pub signing_cert: Vec<u8>,
}

pub fn verify_report(report: &EndorsedAttestationReport) -> Result<(), Error> {
    let now = match webpki::Time::try_from(SystemTime::now()) {
        Ok(r) => r,
        Err(e) => {
            return Err(Error::OtherError(anyhow!(
                "webpki::Time::try_from failed with {:?}",
                e
            )))
        }
    };

    let root_ca_pem = pem::parse(IAS_REPORT_CA).expect("failed to parse pem bytes");
    let root_ca = root_ca_pem.contents;

    let mut root_store = rustls::RootCertStore::empty();
    root_store
        .add(&rustls::Certificate(root_ca.clone()))
        .map_err(Error::WebPKIError)?;

    let trust_anchors: Vec<webpki::TrustAnchor> = root_store
        .roots
        .iter()
        .map(|cert| cert.to_trust_anchor())
        .collect();

    let mut chain: Vec<&[u8]> = Vec::new();
    chain.push(&root_ca);

    let report_cert =
        webpki::EndEntityCert::from(&report.signing_cert).map_err(Error::WebPKIError)?;

    let _ = report_cert
        .verify_is_valid_tls_server_cert(
            SUPPORTED_SIG_ALGS,
            &webpki::TLSServerTrustAnchors(&trust_anchors),
            &chain,
            now,
        )
        .map_err(Error::WebPKIError)?;

    let _ = report_cert
        .verify_signature(
            &webpki::RSA_PKCS1_2048_8192_SHA256,
            &report.report,
            &report.signature,
        )
        .map_err(Error::WebPKIError)?;

    Ok(())
}

#[derive(Clone)]
pub struct Quote {
    pub raw: sgx_quote_t,
    pub status: String,
    pub timestamp: i64,
}

impl Quote {
    pub fn get_enclave_key_address(&self) -> Result<Address, Error> {
        let data = self.raw.report_body.report_data.d;
        if data.len() < 20 {
            Err(Error::InvalidReportDataError(format!(
                "unexpected report data length: {}",
                data.len()
            )))
        } else {
            Ok(Address::from(&data[..20]))
        }
    }
}

pub fn parse_quote_from_report(attn_report: &[u8]) -> Result<Quote, Error> {
    let attn_report: Value = serde_json::from_slice(attn_report).unwrap();

    let timestamp = if let Value::String(time) = &attn_report["timestamp"] {
        let time_fixed = time.clone() + "+0000";
        DateTime::parse_from_str(&time_fixed, "%Y-%m-%dT%H:%M:%S%.f%z")
            .unwrap()
            .timestamp()
    } else {
        return Err(Error::InvalidAttestationReportError(
            "Failed to fetch timestamp from attestation report".into(),
        ));
    };

    if let Value::String(version) = &attn_report["version"] {
        if version != "4" {
            return Err(Error::UnexpectedAttestationReportVersionError(
                "4".into(),
                version.into(),
            ));
        }
    }

    let quote_status = if let Value::String(quote_status) = &attn_report["isvEnclaveQuoteStatus"] {
        match quote_status.as_ref() {
            "OK" => (),
            "GROUP_OUT_OF_DATE"
            | "GROUP_REVOKED"
            | "SW_HARDENING_NEEDED"
            | "CONFIGURATION_NEEDED"
            | "CONFIGURATION_AND_SW_HARDENING_NEEDED" => (),
            _ => {
                return Err(Error::InvalidQuoteStatusError(quote_status.to_string()));
            }
        }
        quote_status
    } else {
        return Err(Error::InvalidAttestationReportError(
            "Failed to fetch isvEnclaveQuoteStatus from attestation report".into(),
        ));
    };

    match &attn_report["isvEnclaveQuoteBody"] {
        Value::String(quote_raw) => {
            let quote = base64::decode(&quote_raw).unwrap();

            let sgx_quote: sgx_quote_t = unsafe { ptr::read(quote.as_ptr() as *const _) };
            Ok(Quote {
                raw: sgx_quote,
                status: quote_status.into(),
                timestamp,
            })
        }
        _ => Err(Error::InvalidAttestationReportError(
            "Failed to fetch isvEnclaveQuoteStatus from attestation report".into(),
        )),
    }
}
