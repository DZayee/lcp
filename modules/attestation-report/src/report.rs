use crate::errors::Error;
use crate::prelude::*;
use chrono::prelude::DateTime;
use core::fmt::Debug;
use crypto::Address;
use lcp_types::Time;
use serde::{Deserialize, Serialize};
use sgx_types::{metadata::metadata_t, sgx_measurement_t, sgx_quote_t};
use tendermint::Time as TmTime;

/// AttestationReport can be endorsed by either the Intel Attestation Service
/// using EPID or Data Center Attestation
/// Service (platform dependent) using ECDSA.
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EndorsedAttestationVerificationReport {
    /// Attestation report generated by the hardware
    pub avr: String,
    /// Singature of the report
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
    /// Certificate matching the signing key of the signature
    #[serde(with = "serde_base64")]
    pub signing_cert: Vec<u8>,
}

impl EndorsedAttestationVerificationReport {
    pub fn get_avr(&self) -> Result<AttestationVerificationReport, Error> {
        Ok(serde_json::from_slice(self.avr.as_bytes()).map_err(Error::serde_json)?)
    }
}

// AttestationVerificationReport represents Intel's Attestation Verification Report
// https://api.trustedservices.intel.com/documents/sgx-attestation-api-spec.pdf
#[derive(Default, Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct AttestationVerificationReport {
    pub id: String,
    pub timestamp: String,
    pub version: i64,
    #[serde(alias = "isvEnclaveQuoteStatus")]
    pub isv_enclave_quote_status: String,
    #[serde(alias = "isvEnclaveQuoteBody")]
    pub isv_enclave_quote_body: String,
    #[serde(alias = "revocationReason")]
    pub revocation_reason: Option<i64>,
    #[serde(alias = "pseManifestStatus")]
    pub pse_manifest_status: Option<i64>,
    #[serde(alias = "pseManifestHash")]
    pub pse_manifest_hash: Option<String>,
    #[serde(alias = "platformInfoBlob")]
    pub platform_info_blob: Option<String>,
    pub nonce: Option<String>,
    #[serde(alias = "epidPseudonym")]
    pub epid_pseudonym: Option<Vec<u8>>,
    #[serde(alias = "advisoryURL")]
    pub advisory_url: String,
    #[serde(alias = "advisoryIDs")]
    pub advisory_ids: Vec<String>,
}

impl TryFrom<&AttestationVerificationReport> for Vec<u8> {
    type Error = serde_json::Error;

    fn try_from(value: &AttestationVerificationReport) -> Result<Self, Self::Error> {
        serde_json::to_vec(value)
    }
}

impl TryFrom<&[u8]> for AttestationVerificationReport {
    type Error = serde_json::Error;

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        serde_json::from_slice(value)
    }
}

impl AttestationVerificationReport {
    pub fn parse_quote(&self) -> Result<Quote, Error> {
        if self.version != 4 {
            return Err(Error::unexpected_attestation_report_version(
                4,
                self.version,
            ));
        }

        let time_fixed = self.timestamp.clone() + "+0000";
        let dt = DateTime::parse_from_str(&time_fixed, "%Y-%m-%dT%H:%M:%S%.f%z").unwrap();

        let attestation_time =
            TmTime::from_unix_timestamp(dt.timestamp(), dt.timestamp_subsec_nanos())
                .map_err(lcp_types::TimeError::tendermint)
                .map_err(Error::time_error)?
                .into();

        let quote = base64::decode(&self.isv_enclave_quote_body).map_err(Error::base64)?;
        let sgx_quote: sgx_quote_t = unsafe { core::ptr::read(quote.as_ptr() as *const _) };
        Ok(Quote {
            raw: sgx_quote,
            status: self.isv_enclave_quote_status.clone(),
            attestation_time,
        })
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Quote {
    pub raw: sgx_quote_t,
    pub status: String,
    pub attestation_time: Time,
}

impl Quote {
    pub fn get_enclave_key_address(&self) -> Result<Address, Error> {
        let data = self.raw.report_body.report_data.d;
        if data.len() < 20 {
            Err(Error::invalid_report_data_size(data.len()))
        } else {
            Ok(Address::from(&data[..20]))
        }
    }

    pub fn get_mrenclave(&self) -> sgx_measurement_t {
        self.raw.report_body.mr_enclave
    }

    pub fn match_metadata(&self, metadata: &metadata_t) -> Result<(), Error> {
        if self.raw.report_body.mr_enclave.m != metadata.enclave_css.body.enclave_hash.m {
            Err(Error::mrenclave_mismatch(
                self.raw.report_body.mr_enclave.m,
                metadata.enclave_css.body.enclave_hash.m,
            ))
        } else {
            Ok(())
        }
    }
}

mod serde_base64 {
    use super::*;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S: Serializer>(v: &Vec<u8>, s: S) -> Result<S::Ok, S::Error> {
        let base64 = base64::encode(v);
        String::serialize(&base64, s)
    }

    pub fn deserialize<'de, D: Deserializer<'de>>(d: D) -> Result<Vec<u8>, D::Error> {
        let base64 = String::deserialize(d)?;
        base64::decode(base64.as_bytes()).map_err(|e| serde::de::Error::custom(e))
    }
}
