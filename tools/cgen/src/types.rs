use attestation_report::EndorsedAttestationVerificationReport;
use commitments::{StateCommitmentProof, UpdateClientCommitmentProof};
use ecall_commands::{InitClientInput, InitClientResult, UpdateClientInput, VerifyMembershipInput};
use lcp_types::ClientId;
use serde::{Deserialize, Serialize};

pub trait JSONSerializer {
    fn to_json_string(&self) -> Result<String, anyhow::Error>;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONEndorsedAttestationVerificationReport {
    /// Attestation report generated by the hardware
    pub avr: String,
    /// Singature of the report
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
    /// Certificate matching the signing key of the signature
    #[serde(with = "serde_base64")]
    pub signing_cert: Vec<u8>,
    /// mrenclave of the target enclave
    #[serde(with = "serde_base64")]
    pub mrenclave: Vec<u8>,
    /// address of enclave key
    #[serde(with = "serde_base64")]
    pub enclave_key: Vec<u8>,
}

impl JSONSerializer for EndorsedAttestationVerificationReport {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let this = self.clone();
        let avr = this.get_avr()?;
        let quote = avr.parse_quote()?;
        Ok(serde_json::to_string(
            &JSONEndorsedAttestationVerificationReport {
                avr: this.avr,
                signature: this.signature,
                signing_cert: this.signing_cert,
                mrenclave: quote.get_mrenclave().m.to_vec(),
                enclave_key: quote.get_enclave_key_address()?.0.to_vec(),
            },
        )?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONAny {
    type_url: String,
    #[serde(with = "serde_base64")]
    value: Vec<u8>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONInitClientInput {
    any_client_state: JSONAny,
    any_consensus_state: JSONAny,
    current_timestamp: u64, // second
}

impl JSONSerializer for InitClientInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let s = serde_json::to_string(&JSONInitClientInput {
            any_client_state: JSONAny {
                type_url: self.any_client_state.type_url.clone(),
                value: self.any_client_state.value.clone(),
            },
            any_consensus_state: JSONAny {
                type_url: self.any_consensus_state.type_url.clone(),
                value: self.any_consensus_state.value.clone(),
            },
            current_timestamp: self.current_timestamp.as_unix_timestamp_secs(),
        })?;
        Ok(s)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONInitClientResult {
    pub client_id: ClientId,
    pub proof: JSONUpdateClientCommitmentProof,
}

impl JSONSerializer for InitClientResult {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let proof = self.proof.clone();
        Ok(serde_json::to_string(&JSONInitClientResult {
            client_id: self.client_id.clone(),
            proof: JSONUpdateClientCommitmentProof {
                commitment_bytes: proof.commitment_bytes,
                signer: proof.signer,
                signature: proof.signature,
            },
        })?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONUpdateClientInput {
    pub client_id: ClientId,
    pub any_header: JSONAny,
    pub include_state: bool,
    pub current_timestamp: u64, // second
}

impl JSONSerializer for UpdateClientInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let s = serde_json::to_string(&JSONUpdateClientInput {
            client_id: self.client_id.clone(),
            any_header: JSONAny {
                type_url: self.any_header.type_url.clone(),
                value: self.any_header.value.clone(),
            },
            include_state: self.include_state,
            current_timestamp: self.current_timestamp.as_unix_timestamp_secs(),
        })?;
        Ok(s)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONUpdateClientCommitmentProof {
    #[serde(with = "serde_base64")]
    pub commitment_bytes: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub signer: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
}

impl JSONSerializer for UpdateClientCommitmentProof {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(&JSONUpdateClientCommitmentProof {
            commitment_bytes: self.commitment_bytes.clone(),
            signer: self.signer.clone(),
            signature: self.signature.clone(),
        })?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONStateCommitmentProof {
    #[serde(with = "serde_base64")]
    pub commitment_bytes: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub signer: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub signature: Vec<u8>,
    #[serde(with = "serde_base64")]
    pub proof: Vec<u8>,
}

impl JSONSerializer for StateCommitmentProof {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        let mut st = rlp::RlpStream::new_list(3);
        st.append(&self.commitment_bytes)
            .append(&self.signer)
            .append(&self.signature);
        let proof = st.out().to_vec();

        Ok(serde_json::to_string(&JSONStateCommitmentProof {
            commitment_bytes: self.commitment_bytes.clone(),
            signer: self.signer.clone(),
            signature: self.signature.clone(),
            proof,
        })?)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct JSONVerifyMembershipInput {
    pub client_id: ClientId,
    #[serde(with = "serde_base64")]
    pub prefix: Vec<u8>,
    pub path: String,
    #[serde(with = "serde_base64")]
    pub value: Vec<u8>,
}

impl JSONSerializer for VerifyMembershipInput {
    fn to_json_string(&self) -> Result<String, anyhow::Error> {
        Ok(serde_json::to_string(&JSONVerifyMembershipInput {
            client_id: self.client_id.clone(),
            prefix: self.prefix.clone(),
            path: self.path.clone(),
            value: self.value.clone(),
        })?)
    }
}

mod serde_base64 {
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    pub fn serialize<S: Serializer>(v: &Vec<u8>, s: S) -> Result<S::Ok, S::Error> {
        let base64 = base64::encode(v);
        String::serialize(&base64, s)
    }

    pub fn deserialize<'de, D: Deserializer<'de>>(d: D) -> Result<Vec<u8>, D::Error> {
        let base64 = String::deserialize(d)?;
        base64::decode(base64.as_bytes()).map_err(|e| serde::de::Error::custom(e))
    }
}
